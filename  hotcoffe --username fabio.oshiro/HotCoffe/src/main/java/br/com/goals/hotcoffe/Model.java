package br.com.goals.hotcoffe;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

public class Model implements Cloneable{
	private HashMap<String,Attribute> attributeMap = new HashMap<String,Attribute>();
	HashSet<Attribute> attributeChanged = new HashSet<Attribute>();
	private String name;
	private long id;
	public Model(String name){
		this.name = name;
	}
	protected Model(){
		
	}
	
	
	public String getName(){
		return name;
	}
	
	public void delete(){
		
	}
	
	public void update(){
		
	}
	
	public void save(){
		
	}
	
	public Long getId(){
		return id;
	}
	
	public void setId(long id){
		this.id=id;
	}
	
	public Long getLong(String key){
		return (Long) attributeMap.get(key).value;
	}
	
	public Integer getInteger(String key){
		return (Integer) attributeMap.get(key).value;
	}
	
	public String getString(String key){
		return (String) attributeMap.get(key).value;
	}
	
	public Double getDouble(String key){
		return (Double) attributeMap.get(key).value;
	}
	
	public void set(String key,Object value) throws Exception{
		Attribute a = attributeMap.get(key);
		if (a!=null){
			//verifica se pode ser null
			if(value==null && !a.nullAble) throw new Exception(Messages.getString(name+"."+key+".NotNull"));
			//verificar os tipos
			if(a.className.equals(value.getClass().getName())){
				a.value = value;
			}else if(a.className.equals("java.sql.Timestamp") && value.getClass().getName().equals("java.util.Date")){
				a.value = new java.sql.Timestamp(((java.util.Date)value).getTime());
			}else{
				throw new Exception(Messages.getString(name+"."+key+".TypeError"));
			}
		}else{
			//nao ha atributo para colocar o valor
			throw new Exception(Messages.getString(name+"."+key+".NotFound"));
		}
	}
	
	public Date getDate(String key){
		return (Date) attributeMap.get(key).value;
	}
	
	@SuppressWarnings("unchecked")
	public List<Model> getListModel(String key){
		return (List<Model>) attributeMap.get(key).value;
	}
	
	public Model getModel(String key){
		return (Model) attributeMap.get(key).value;
	}
	/**
	 * Cria um atributo
	 * @param columnName
	 * @param columnClassName
	 * @param columnDisplaySize
	 * @param nullAble
	 */
	protected void createAttribute(String columnName, String columnClassName, int columnDisplaySize, boolean nullAble,boolean autoGeneratedValue) {
		Attribute a = new Attribute();
		a.nullAble = nullAble;
		a.className = columnClassName;
		a.size = columnDisplaySize;
		a.name = columnName;
		a.autoGeneratedValue = autoGeneratedValue;
		a.parent = this;
		attributeMap.put(columnName, a);
	}
	private String nameIdentifier;
	
	void setNameIdentifier(String name){
		nameIdentifier = name;
	}
	
	String getNameIdentifier() {
		return nameIdentifier;
	}
	
	List<Attribute> getAttributeList(){
		ArrayList<Attribute> a = new ArrayList<Attribute>();
		a.addAll(attributeMap.values());
		return a;
	}
	
	public Object clone() throws CloneNotSupportedException {
		Model model =(Model) super.clone();
		model.attributeChanged = new HashSet<Attribute>();
		List<Attribute> a =getAttributeList();
		for(Attribute at:a){
			Attribute attributeClone =(Attribute) at.clone();
			model.attributeMap.put(at.name, attributeClone);
		}
		return model;
	}
	
}
